---
title: "Animando a molécula"
---

## Alguns comandos de animação para os modelos

|       Animações permitem a representação de moléculas de modo mais lúdico e representativo. Para agregar valor ainda maior à visualização tridimensional de estruturas moleculares, o *Jmol* conta com alguns comandos para o posicionamento espacial do modelo, bem como para a criação de animações, como:

## Rotacionar e transladar

|       Essas ações constituem uma forma simples de reposicionar o modelo no espaço. Basta inserir o eixo e o ângulo em que se deseja o movimento (*x,y,z*). Ou apenas o ângulo, com o movimento padrão no eixo das abscissas (*X*). Seguem exemplos:

```{r, eval=FALSE}
rotate 20 # 20 graus
rotate x 90 # eixo x
translate y 50 # valor representa o percentual da janela (100 - fora; 0 - centro)

Obs: para retornar à posição original: `reset`
```

## Girar

|       Essa ação, por sua vez, é mais "impactante", já que permite a rotação do modelo a uma certa velocidade indefinidamente, até um comando de parada. Como na anterior, pode-se digitar somente o comando para a rotação padrão no eixo das abcissas, ou fornecer o eixo (*x,y.z*):

```{r, eval=FALSE}
spin 10 # rotacional, com velocidade de 10 graus por quadro
spin z -15 # (eixo z)
spin off # interrompe a rotação
```

## Ampliação dos modelos (*zoom*)

|       É possível também ampliar ou reduzir o tamanho de uma molécula no ecrã combinando-se o comando `zoom` à quantidades, tal como segue:

```{r, eval=FALSE}
Ampliação 2x: zoom in
Ampliação em 3x: zoom *3 
Redução em 2x: zoom out 
Redução em 3x: zoom /3 
Eliminar ampliação: zoom off 
Restrição a um ligante e ampliação: restrict ligand; zoom 0

Obs: para retornar ao tamanho original: `zoom 0`
```

|       Com ampliações, reduções, rotações, translações, é possível que você queira retornar ao modelo na sua configuração de tamanho e coordenadas originais. Para isto:

```{r, eval=FALSE}
center; zoom 0 # centraliza e redimensiona o modelo a seu tamanho original
```

### Ampliação animada (*zoomTo*)

|       Esse recurso é bem mais *"chique"*, já que permite visualizar de forma ampliada temporalmente algumas partes de interesse do modelo. Isso é particularmente bacana com biomacromoléculas, como para sítios de interação de ligantes ou grupos prostéticos, ou sítios de reação em catálise enzimática. Mas também impacta a visualização de pequenas moléculas, posto que os modelos crescem ou reduzem de forma animada no ecrã; pode-se também focar num átomo específico para chamar a atenção na molécula. A sintaxe da expressão é:

```{r, eval=FALSE}
zoomto tempo tamanho #...ou, se quiser um grupo de átomos em especial (ligante, por ex)...
zoomto tempo (expressão do átomo/grupo) tamanho
```

|       Experimente carregar moléculas pequenas e proteínas, ilustrando o comando `zoomTo` como segue:

```{r, eval=FALSE}
Aumentar em 3x, meio segundo por vez: zoomto 0.5 *3 
Aumentar em 4x, meio segundo por vez: zoomto 0.5 400 
Focar num ligante com ampliação de 2x: zoomto 2(ligand) 0
Focar num ligante com ampliação de 4x, a meio segundo por vez: zoomto 0.5(ligand)* 4
```

## Pausa

|       Um comando muito interessante para o *Jmol*, bem como para outras linguagens de programação, é `delay`. Essa ação permite que o *script* interrompa uma ação por algum tempo, medido em segundos, e limitado ao mínimo de um segundo. Experimente:

```{r, eval=FALSE}
load $ribose # carrega uma ribose
spin 50 # rotaciona no eixo X
delay 5 # aguarda 5s
spin off # interrompe a rotação
wireframe only # represeta em arame, somente
wireframe 130 # espesssura do arame
color translucent # cor translúcida
```

## Laço

|       O *Jmol* possui alguns comandos normalmente utilizados em linguagens de programação, embora não seja esse o escopo do presente trabalho. Se quiser *"ir fundo"*, consulte o [manual de referência de comandos do *Jmol*](https://chemapps.stolaf.edu/jmol/docs/) para os comandos de programação: *if, ifelse, for, while, step, break, wait, pause, case, continue, quit, loop*.

|       Mas entre esses comandos variados, o de *laço iterativo* (`loop`) pode ser de valia ao ensino, por exemplo, para quando se desejar chamar à atenção para uma ligação, um átomo ou grupo de átomos. Exemplificando:

```{r, eval=FALSE}
load $acetate # carrega um modelo de acetato
color bonds red # coloração vermelha às ligações
delay 1 # aguarda 1 segundo
color bonds green # troca a coloração para verde
loop 1 # realiza o laço (efeito "piscante")
```

|       Para deixar o laço, ou seja, interromper a sequência em *loop*, digita-se *`quit`*.

## Combinando rotações, translações, e ampliações no tempo

|       O *Jmol* oferece dois comandos básicos para isso: `move` e `moveTo`. A diferença é que `move` reorienta o modelo em relação à sua posição atual (*movimento relativo*), e `moveTo` o faz em relação à posição original do modelo (*movimento absoluto*).

|       Na prática, contudo, o comando `move` é mais simples de executar, dependendo somente de parâmetros de rotação e translação, ao passo que `moveTo` é bem mais complexo. Esse depende de parâmetros de orientação manualmente obtidos pelo *Jmol*.

### Move

|       Para o comando `move` bastam os parâmetros que se deseja modificar (*nove* no total). Dependendo do que se deseja não há necessidade de usar todos os parâmetros, e que são fornecidos abaixo:

```{r,eval=FALSE}
move rotX rotY rotZ zoom dx dy dz slab time

Onde:
  rotX, Y ou Z = rotação no eixo X, Y, ou Z
  zoom = ampliação ou redução
  dX, Y ou Z = translação no eixo X, Y ou Z
  slab = plano de fatiamento da molécula
  time = tempo total envolvido no movimento
```

|       Seguem alguns exemplos:

```{r, eval=FALSE}
move 90 180 0 0 0 0 0 0 21 # rotaciona o modelo por 45 graus em torno do eixo X e por 180 graus no eixo Y, e empregando um movimento gradual de 2 segundos
move 0 0 0 0 0 35 0 0 0.5 # reduz o modelo em 35% de seu tamanho, e com movimento gradual de 0,5 segundos
move 45 0 90 150 0 30 0 0 5 # rotaciona 45 graus no eixo X e 90 graus no eixo Z, ampliando o modelo em 150% e transladando-o por 30%, tudo ao longo de 5 segundos.
```

### MoveTo

|       Resulta em orientação *absoluta* do modelo, não dependendo de suas coordenadas anteriores. Sua inserção não é simples, pois depende dos dados da orientação do modelo quando carregado pela 1a. vez, e que pode ser obtida por:

```{r, eval=FALSE}
show orientation
```

|       Um exemplo de resultado pelo comando é:

```{r, eval=FALSE}
moveto /* time, axisAngle */ 1.0 { 616 -708 -346 47.68} /* zoom, translation */  400.0 0.0 0.0  /* center, rotationRadius */ {15.174467 28.719118 4.726837} 35.148052 /* navigation center, translation, depth */ {0 0 0} 0 0 0 /* cameraDepth, cameraX, cameraY */  3.0 0.0 0.0;
#OR
#Follows Z-Y-Z convention for Euler angles
reset;center {15.174467 28.719118 4.726837}; rotate z 130.27; rotate y 44.57; rotate z -147.67; zoom 400.0;
```

|       Perceba que há dois conjuntos de comandos um pelo *moveTo* e outro por *reset, center, rotate e translate*. Para obter o modelo nas coordenadas originais, basta copiar um ou outro conjunto de dados.

|       Usando-se o 1o. conjunto (*moveTo*), copia-se a linha e altera-se o tempo de animação, no caso o valor 1.0 em "axisAngle \*/ 1.0".

## Comparando dois modelos no ecrã

|       Compara 2 modelos e reorienta as coordenadas do segundo para justapor-se ao primeiro, por um algoritmo de correlação.

```{r, eval=FALSE}
load files "$tyrosine" "$epinephrine";
frame *;
compare {2.1} {1.1} rotate translate 5.0 
```

## Navigate

|       O comando permite explorar o modelo simulando um passeio panorâmico ao interior da estrutura. Os parâmetros envolvem o tempo de percuro (ou 2s quando omitido). Exemplificando:

```{r, eval=FALSE}
navigate depth 50 # imersão no modelo em 2s
navigate 3 rotate y 20 # rotaciona 20o no eixo y
navigate 4 trace # passeia pelo modelo em 4s
navigate 3 translate {30 50 70} modelo translada levemente por 3s
navigate 5 center {10 20 30} # sonda ao lado do modelo, e nas coordenadas x, y, z
navigate 2 depth 30 / 5 rotate 180 / depth 20 / translate X 10
```

<!-- ## Exemplos de animações para moléculas no *Jmol* -->
